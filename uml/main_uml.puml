@startuml

skinparam class {
BackgroundColor<<Main>> Snow
BorderColor<<Main>> Orange
}
skinparam stereotypeCBackgroundColor<< Main >> Khaki

class ApplicationClient<<Main>>
{
    +{static}main()
    -{static}simulateSystem()
}

class Application
{
    +register()
    +entrance()
    +exit()
}

ApplicationClient -> Application
ApplicationClient -> ConsoleDisplay

package "Payment System"{
   interface IPaymentMachine
   {
   }

   class CashMachine implements IPaymentMachine
   {
       +enterCoin(Denomination coins)
       +acceptPayment(): void
       -disposeChange(): void
   }

   class Denomination
   {
       -valueInGR: int
       +amount: int
   }

   interface CashChangeStrategy
   {

   }
}

package "Console Environment"{
    interface IDisplay{
        +ShowMessage(String msg): void
    }

    class ConsoleDisplay implements IDisplay{
    }

    class MachineScreenDisplay implements IDisplay{
    }

    Note bottom of MachineScreenDisplay: This would API of real\nparking machine, but instead\nit uses console effectively\ncreating proxy pattern.


    MachineScreenDisplay -> ConsoleDisplay
}


package "User Interface"<<UI systems of various devices>>{


    class Device <<Abstract>>{
        -acceptButtonPressed(): void
        +AddButtonObserver(ButtonKey key, IGuiEventListener observer): void
        +RemoveButtonObserver(ButtonKey key, IGuiEventListener observer): void
    }


    class RegisterSystem extends Device
    {
        -cancelButtonPressed(): void
        +keyboardInput(): string
    }

    class Gate<<Abstract>> extends Device{
        +open()
        -closeIfClear()
    }



    enum ButtonKey{
        ACCEPT_BUTTON
        CANCEL_BUTTON
    }


    class ExitParkingMachine extends Gate
    {
        -disposeChange(Denomination coins): void
    }

    class EntranceParkingMachine extends Gate
    {

    }


    interface IGuiEventListener
    {
        -buttonPressed(): void
    }
    note left: observer\npattern


    Device ..> MachineScreenDisplay: uses
}



package ParkingSystem{
    class TicketDatabase{
        -normalCounter: int
        -handicappedCounter: int
        +addTicket(): void
        +evaluateTicket(Ticket t):
        +tryDriveIn(): void
        +driveOut(): void
    }

    class Ticket{
        -code: string
        -entranceTime: timestamp
    }

    interface ITicketCodeGenerator
    {
        +generate()
    }
    note left: strategy\npattern

    class GUIDGenerator implements ITicketCodeGenerator

    TicketDatabase *-- Ticket
    TicketDatabase -> ITicketCodeGenerator

    ' ? class PremiumPlaces implements IPlaceCounter
}

package PremiumUser{

    interface IDriverDatabase
    {
        +register(String driversPlate): void
    }
    class PremiumProxy implements IDriverDatabase{

    }
    class PremiumDatabase implements IDriverDatabase{
    }


    PremiumProxy --> PremiumDatabase :uses
}

CashMachine o--> CashChangeStrategy
CashMachine *-- Denomination
Denomination . CashChangeStrategy


IGuiEventListener <|.. CashMachine


Device o---"multiple lists" IGuiEventListener

Gate --> TicketDatabase: create and use
RegisterSystem --> PremiumProxy

TicketDatabase::evaluateTicket --> IPaymentMachine :initialize\npayment
Application o-->"n" Device

Device - ButtonKey

@enduml